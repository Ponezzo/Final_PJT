<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Squares with Random Movement</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #0e1b26;
            overflow: hidden;
        }

        .flower {
            position: absolute;
            width: 150px;  /* 크기 1.5배로 변경 */
            height: 150px; /* 크기 1.5배로 변경 */
            background-color: pink;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>

    <!-- 꽃 10개 생성 -->
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>
    <div class="flower"></div>

    <script>
        const flowers = document.querySelectorAll('.flower');
        const friction = 0.98; // 마찰력
        const bounceFactor = 0.7; // 충돌 반응 계수
        const maxDistance = 300; // 최대 이동 거리 (300px)
        const minDistance = 150; // 꽃들 간 최소 거리 (충돌 방지)

        let flowerPositions = [];
        flowers.forEach(flower => {
            flowerPositions.push({
                element: flower,
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                targetX: Math.random() * window.innerWidth,
                targetY: Math.random() * window.innerHeight,
                vx: 0, // 초기 속도 0으로 설정
                vy: 0, // 초기 속도 0으로 설정
                moving: false, // 꽃이 움직이는지 여부
                moveTime: 0, // 이동 시간
                maxMoveTime: 5000, // 3초 동안 움직이도록 설정
            });

            flower.style.left = flowerPositions[flowerPositions.length - 1].x + 'px';
            flower.style.top = flowerPositions[flowerPositions.length - 1].y + 'px';
        });

        let animationTime = 200000; // 200초 -> 200,000밀리초
        let startTime = Date.now();

        // 꽃을 이동시키기 위한 함수
        function moveFlower(flower) {
            if (flower.moving) {
                let distance = Math.sqrt(Math.pow(flower.targetX - flower.x, 2) + Math.pow(flower.targetY - flower.y, 2));

                // 목표 위치까지의 거리 계산
                if (distance > 1) {
                    // 목표 위치로 향하는 속도 계산 (느리게 움직이기 위해 속도 조절)
                    let directionX = (flower.targetX - flower.x) / distance;
                    let directionY = (flower.targetY - flower.y) / distance;

                    flower.vx = directionX * 0.3; // 느리게 이동 (속도 0.3)
                    flower.vy = directionY * 0.3; // 느리게 이동 (속도 0.3)

                    flower.x += flower.vx;
                    flower.y += flower.vy;

                    // 3초 내에 목표에 도달하면 계속 움직이지 않음
                    if (flower.moveTime >= flower.maxMoveTime) {
                        flower.moving = false;
                        flower.moveTime = 0; // 이동 시간 초기화
                    } else {
                        flower.moveTime += 1000 / 60; // 1초당 60프레임을 가정
                    }

                } else {
                    flower.x = flower.targetX;
                    flower.y = flower.targetY;
                    flower.moving = false; // 목표 위치에 도달하면 멈춤
                }

                // 화면 경계 체크
                checkScreenBoundary(flower);

                flower.element.style.left = flower.x + 'px';
                flower.element.style.top = flower.y + 'px';
            }
        }

        function randomTargetPosition(flower) {
            // 100px ~ 300px 사이의 거리로 랜덤 위치 선택
            let angle = Math.random() * 2 * Math.PI;
            let distance = 200 + Math.random() * 500;
            flower.targetX = flower.x + distance * Math.cos(angle);
            flower.targetY = flower.y + distance * Math.sin(angle);
            flower.moving = true;
            flower.moveTime = 0;
        }

        function updatePositions() {
            let currentTime = Date.now();
            let elapsedTime = currentTime - startTime;

            if (elapsedTime >= animationTime) {
                return; // 200초가 지나면 애니메이션을 멈춤
            }

            flowerPositions.forEach(flower => {
                // 일정 시간마다 목표 위치를 랜덤하게 설정
                if (!flower.moving) {
                    randomTargetPosition(flower); // 목표 위치 설정
                }

                moveFlower(flower); // 꽃을 이동시킴
            });

            checkCollisions(); // 꽃들 간 충돌 체크
            requestAnimationFrame(updatePositions);  // 애니메이션 반복
        }

        function checkCollisions() {
            for (let i = 0; i < flowerPositions.length; i++) {
                for (let j = i + 1; j < flowerPositions.length; j++) {
                    let flowerA = flowerPositions[i];
                    let flowerB = flowerPositions[j];

                    let dx = flowerA.x - flowerB.x;
                    let dy = flowerA.y - flowerB.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < minDistance) { // 두 꽃이 가까워지면 충돌로 간주 (최소 거리 이하)
                        let angle = Math.atan2(dy, dx);
                        let force = (minDistance - distance) * 0.2; // 충돌 반응 강도 조정
                        let fx = Math.cos(angle) * force;
                        let fy = Math.sin(angle) * force;

                        // 충돌 후 속도 변경 (밀어내는 효과)
                        flowerA.vx += fx;
                        flowerA.vy += fy;
                        flowerB.vx -= fx;
                        flowerB.vy -= fy;

                        // 꽃들이 충돌 후 빠르게 반대 방향으로 밀려나도록 하기 위해 반사 효과 적용
                        flowerA.vx *= bounceFactor;
                        flowerA.vy *= bounceFactor;
                        flowerB.vx *= bounceFactor;
                        flowerB.vy *= bounceFactor;

                        // 겹침을 방지하기 위해 꽃들의 위치를 미세 조정
                        let overlap = minDistance - distance; // 겹친 부분의 길이
                        let moveDistance = overlap / 2; // 겹친 꽃들이 반대 방향으로 이동해야 할 거리
                        flowerA.x += Math.cos(angle) * moveDistance;
                        flowerA.y += Math.sin(angle) * moveDistance;
                        flowerB.x -= Math.cos(angle) * moveDistance;
                        flowerB.y -= Math.sin(angle) * moveDistance;
                    }
                }
            }
        }

        // 화면 경계 체크 함수
        function checkScreenBoundary(flower) {
            // 왼쪽 경계
            if (flower.x < 0) {
                flower.x = 0;
                flower.vx *= -1; // 왼쪽 경계에 닿으면 반대 방향으로 튕김
            }
            // 오른쪽 경계
            if (flower.x > window.innerWidth - flower.element.offsetWidth) {
                flower.x = window.innerWidth - flower.element.offsetWidth;
                flower.vx *= -1; // 오른쪽 경계에 닿으면 반대 방향으로 튕김
            }
            // 위쪽 경계
            if (flower.y < 0) {
                flower.y = 0;
                flower.vy *= -1; // 위쪽 경계에 닿으면 반대 방향으로 튕김
            }
            // 아래쪽 경계
            if (flower.y > window.innerHeight - flower.element.offsetHeight) {
                flower.y = window.innerHeight - flower.element.offsetHeight;
                flower.vy *= -1; // 아래쪽 경계에 닿으면 반대 방향으로 튕김
            }
        }

        // 애니메이션 시작
        window.onload = () => {
            updatePositions();  // 첫 번째 호출이 필요
        };
    </script>

</body>
</html>
